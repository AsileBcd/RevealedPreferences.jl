        - ## Definition of type aliases, to avoir writing Dict of Vector.
        - 
        - """
        -     ChoiceFunction{T}
        - 
        - Alias to define a choice function.
        - """
        - ChoiceFunction{T} = Dict{Vector{T}, T} where T <: Int
        - 
        - """
        -     ChoiceCorrespondence{T}
        - 
        - Alias to define a choice correspondence.
        - """
        - ChoiceCorrespondence{T} = Dict{Vector{T}, Vector{T}} where T <: Int
        - 
        - """
        -     WeightedDiGraph{T <: Int, U <: Number}
        - 
        - Composite types to store all the informations about a DiGraph with weights.
        - 
        - !!! If used to construct directly, it does not check if the `weights` correspond to existing edges in the `dg`.
        - """
        - mutable struct WeightedDiGraph{T <: Int, U <: Number}
       24     dg::DiGraph{T}
        -     weights::Matrix{U}
        - end
        - 
        - """
        -     WeightedDiGraph(n::T) where T <: Int
        - 
        - Constructor of an empty WeightedDiGraph of size `n`.
        - """
        - function WeightedDiGraph(n::T) where T <: Int
        4     dg = DiGraph{T}(n)
        -     we = zeros(Float64, n, n)
        4     return WeightedDiGraph(dg, we)
        - end
        - 
        - """
        -     weights(wdg::WeightedDiGraph)
        - 
        - Return the weights of a given `wdg`.
        - """
       16 weights(wdg::WeightedDiGraph) = wdg.weights
        - 
        - 
        - """
        -     digraph(wdg::WeightedDiGraph)
        - 
        - Return the digraph of a given `wdg`.
        - """
       16 digraph(wdg::WeightedDiGraph) = wdg.dg
        - 
        - """
        -     setofalternatives(cf::Union{ChoiceFunction{T}, ChoiceCorrespondence{T}}) where T <: Int
        - 
        - Look at the number of alternatives in a choice function or correspondence `cf`.
        - 
        - It might be slow if the number of alternatives is large.
        - """
        - function setofalternatives(cf::Union{ChoiceFunction{T}, ChoiceCorrespondence{T}}) where T <: Int
       29     set = Set{T}()
       29     for key in keys(cf)
      310         union!(set, key)
        -     end
       29     return length(set)
        - end
        - 
        - """
        -     overlap(sets::Vector{Vector{T}}) where T <: Number
        - 
        - Compute the matrix of vectors overlap, filling the whole matrix, so that the information is in double.
        - 
        - # Arguments
        - 
        - - `sets`, a vector of vectors, over which we wish to compute the overlap.
        - """
        - function overlap(sets::Vector{Vector{T}}) where T <: Number
        4     l = length(sets)
        4     if l == 0
        1         return zeros(Float64, 0, 0)
        3     elseif l == 1
        1         return ones(Float64, 1, 1)
        -     end
        -     res = zeros(Float64, l, l)
        6     for i = 1:l, j = (i+1):l
        8         res[i, j] = length(intersect(sets[i], sets[j])) / length(union(sets[i], sets[j]))
        -     end
        2     for i = 1:l
        4         res[i, i] = 1.
        -     end
        6     for i = 1:length(sets), j = 1:(i-1)
        6         res[i, j] = res[j, i]
        -     end
        2     return res
        - end
        - 
        - """
        -     revealedpreferences(cf::ChoiceFunction{T}, n::Int = 0) where T <: Int
        - 
        - Create the revealed preferences from an observed choice function `cf`, assuming that the preferences revealed are strict.
        - 
        - # Arguments
        - 
        - - `cf`, a choice function.
        - - `n`, the number of alternatives. If no value is provided, look at all the alternatives in the choice function, which is much slower.
        - """
        - function revealedpreferences(cf::ChoiceFunction{T}, n::Int = 0) where T <: Int
       12     if n == 0
        2         n = setofalternatives(cf)
        2     elseif n < 0
        1         throw(DomainError(n, "should be positive."))
        -     end    
        3     result = DiGraph(n)
        3     for (key, value) = cf
       22         for i = key
       56             if !(i == value)
       78                 add_edge!(result, value, i)
        -             end
        -         end
        -     end
        3     return result
        - end
        - 
        - """
        -     weakstrictrevealedpreferences(cf::ChoiceFunction{T}, n::Int = 0) where T <: Int
        - 
        - Create the revealed preferences from an observed choice function `cf`. 
        - 
        - It assumes that if in the choice function `cf`, we have a set were x in chosen and y was available, and a set where y is chosen and x is available, then x and y are indifferent.
        - 
        - # Arguments
        - 
        - - `cf`, a choice function.
        - - `n`, the number of alternatives. If no value is provided, look at all the alternatives in the choice function, which is much slower.
        - """
        - function weakstrictrevealedpreferences(cf::ChoiceFunction{T}, n::Int = 0) where T <: Int
       12     if n == 0
        2         n = setofalternatives(cf)
        2     elseif n < 0
        1         throw(DomainError(n, "should be positive."))
        -     end    
        3     P = DiGraph(n)
        -     I = Graph(n)
        3     for (S, cS) = cf
       22         for y = S
       56             if cS == y
       22                 continue
       34             elseif has_edge(P, y, cS)
        -                 add_edge!(I, cS, y)
        0                 rem_edge!(P, y, cS)
       68             elseif !has_edge(I, cS, y)
       78                 add_edge!(P, cS, y)
        -             end
        -         end
        -     end
        3     return P, I
        - end
        - 
        - """
        -     weakstrictrevealedpreferences(cc::ChoiceCorrespondence{T}, n::Int = 0) where T <: Int
        - 
        - Create the revealed preferences from an observed choice function `cf`.
        - 
        - It assumes that if in the choice correspondence, we have a set were x in chosen and y was available, and a set where y is chosen and x is available, then x and y are indifferent.
        - 
        - # Arguments
        - 
        - - `cf`, a choice function.
        - - `n`, the number of alternatives. If no value is provided, look at all the alternatives in the choice function, which is much slower.
        - """
        - function weakstrictrevealedpreferences(cc::ChoiceCorrespondence{T}, n::Int = 0) where T <: Int
       12     if n == 0
        2         n = setofalternatives(cc)
        2     elseif n < 0
        1         throw(DomainError(n, "should be positive."))
        -     end    
        3     P = DiGraph(n)
        -     I = Graph(n)
        3     for (S, cS) = cc
       78         for y = S, x = cS
       56             if x == y
       22                 continue
       34             elseif in(y, cS)
        -                 add_edge!(I, x, y)
        -                 rem_edge!(P, x, y)
        0                 rem_edge!(P, y, x)
       34             elseif has_edge(P, y, x)
        -                 add_edge!(I, x, y)
        0                 rem_edge!(P, y, x)
       68             elseif !has_edge(I, x, y)
      134                 add_edge!(P, x, y)
        -             end
        -         end
        -     end
        3     return P, I
        - end
        - 
        - """
        -     strictrevealedpreferences(cc::ChoiceCorrespondence{T}, n::Int = 0) where T <: Int
        - 
        - Create the strict revealed preferences from an observed choice correspondence `cc`.
        - 
        - # Arguments
        - 
        - - `cc`, a choice function.
        - - `n`, the number of alternatives. If no value is provided, look at all the alternatives in the choice function, which is much slower.
        - """
        - function strictrevealedpreferences(cc::ChoiceCorrespondence{T}, n::Int = 0) where T <: Int
       18     if n == 0
        3         n = setofalternatives(cc)
        4     elseif n < 0
        1         throw(DomainError(n, "should be positive."))
        -     end    
        6     result = DiGraph(n)
        6     for (S, cS) = cc
       88         for x = cS,  y = S
      224             if !in(y, cS)
      200                 add_edge!(result, x, y)
        -             end
        -         end
        -     end
        6     return result
        - end
        - 
        - """
        -     strictrevealedpreferences(cc::ChoiceCorrespondence{T}, n::Int = 0) where T <: Int
        - 
        - Create the revealed indifferences from an observed choice correspondence `cc`.
        - 
        - # Arguments
        - 
        - - `cc`, a choice function.
        - - `n`, the number of alternatives. If no value is provided, look at all the alternatives in the choice function, which is much slower.
        - """
        - function indifferentrevealedpreferences(cc::ChoiceCorrespondence{T}, n::Int = 0) where T <: Int
       16     if n == 0
        3         n = setofalternatives(cc)
        3     elseif n < 0
        1         throw(DomainError(n, "should be positive."))
        -     end  
        5     result = Graph(n)
        5     for cS in values(cc)
       66         for x in cS,  y in cS
       33             if !(x == y)
       99                 add_edge!(result, x, y)
        -             end
        -         end
        -     end
        5     return result
        - end
        - 
        - """
        -     revealedpreferences(cc::ChoiceCorrespondence{T}, n::Int = 0) where T <: Int
        - 
        - Create the revealed preferences from an observed choice correspondence `cc`, including indifference and strict preferences.
        - 
        - # Arguments
        - 
        - - `cc`, a choice correspondence.
        - - `n`, the number of alternatives. If no value is provided, look at all the alternatives in the choice function, which is much slower.
        - """
        - function revealedpreferences(cc::ChoiceCorrespondence{T}, n::Int = 0) where T <: Int
        8     if n == 0
        2         n = setofalternatives(cc)
        2     elseif n < 0
        1         throw(DomainError(n, "should be positive."))
        -     end  
        3     P = strictrevealedpreferences(cc, n)
        3     I = indifferentrevealedpreferences(cc, n)  
        3     return P, I
        - end
        - 
        - """
        -     revealedpreferencesweighted(cf::ChoiceFunction{T}, n::Int = 0) where T <: Int
        - 
        - Create the revealed preferences from an observed choice function `cf`, weighting each relation by the number of time an alternative has been chosen over the other.
        - 
        - # Arguments
        - 
        - - `cf`, a choice function.
        - - `n`, the number of alternatives. If no value is provided, look at all the alternatives in the choice function, which is much slower.
        - """
        - function revealedpreferencesweighted(cf::ChoiceFunction{T}, n::Int = 0) where T <: Int
       22     if n == 0
        5         n = setofalternatives(cf)
        1     elseif n < 0
        1         throw(DomainError(n, "should be positive."))
        -     end    
        5     result = WeightedDiGraph(n)
        5     for (key, value) in cf
       11         for i in key
       28             i == value && continue
        -             add_edge!(digraph(result), value, i)
       39             RevealedPreferences.weights(result)[value, i] += 1
        -         end
        -     end
        5     return result
        - end
        - 
        - """
        -     strictrevealedpreferences(price::Matrix{T}, quantity::Matrix{T}) where T <: Number
        - 
        - Create the strict revealed preferences from observed prices `price` and quantities `quantity`.
        - 
        - Assumes that each period is a row, and that the prices and goods are in the same place for the same period in the matrices.
        - 
        - # Arguments
        - 
        - - `price`, the observed prices;
        - - `quantity`, the observed quantities purchased at the given prices;
        - - `aei`, a coefficient to loosen or tighten the budget constraint. Used to compute the Afriat Efficiency Index. When equal to 1 (the default), it is traditional revealed preferences.
        - """
        - function strictrevealedpreferences(price::Matrix{T}, quantity::Matrix{T}, aei::Number = 1) where T <: Number
        -     l = size(price, 1)
        -     result = DiGraph(l)
        -     expenditures = price .* quantity
        -     budget = sum(price .* quantity, dims = 2)
        -     normalizedprice = price ./ budget
        -     for i = 1:l
        -         for j = findall(quantity * normalizedprice[i, :] .- aei .<= eps(1.)) # To take into account rounding errors in the computations.
        -             if i != j
        -                 add_edge!(result, i, j)
        -             end
        -         end
        -     end
        -     return result
        - end
        - 
        - """
        -     transitivecore(dg::DiGraph{T}) where T <: Int
        - 
        - Compute the transitive core of a directed graph `dg`.
        - """
        - function transitivecore(dg::DiGraph{T}) where T <: Int
        3     tc = DiGraph(nv(dg))
        3     for e = edges(dg)
        -         (s,t) = (src(e), dst(e))
       56         if (issubset(outneighbors(dg, t), outneighbors(dg, s)) && issubset(inneighbors(dg, s), inneighbors(dg, t)))
       56             add_edge!(tc, e)
        -         end
        -     end
        3     return tc
        - end
        - 
        - """
        -     strictUCR(cf::ChoiceFunction{T}, n::Int = 0) where T <: Int
        - 
        - Create the Strict UCR graph from an observed choice function `cf`.
        - 
        - To speed-up computations, provide `n`, the number of alternatives.
        - 
        - # Arguments
        - 
        - - `cf`, a choice function.
        - - `n`, the number of alternatives. If no value is provided, look at all the alternatives in the choice function, which is much slower.
        - """
        - function strictUCR(cf::ChoiceFunction{T}, n::Int = 0) where T <: Int
       14     if n == 0
        2         n = setofalternatives(cf)
        3     elseif n < 0
        1         throw(DomainError(n, "should be positive."))
        -     end    
        4     result = DiGraph(n)
        -     forbidden = Set{Tuple{Int, Int}}()
        4     for (key, value) = cf
       30         for i = key
       74             if i == value
       30                 continue
       44             elseif has_edge(result, i, value)
        -                 rem_edge!(result, i, value) 
        4                 push!(forbidden, (i, value))
        8                 push!(forbidden, (value, i))
       80             elseif !in((value, i), forbidden)                
      104                 add_edge!(result, value, i)
        -             end
        -         end
        -     end
        4     return result
        - end
        - 
        - """
        -     strictUCR(cc::ChoiceCorrespondence{T}, n::Int = 0) where T <: Int
        - 
        - Create the Strict UCR graph from an observed choice correspondence `cc`.
        - 
        - To speed-up computations, provide `n`, the number of alternatives.
        - 
        - # Arguments
        - 
        - - `cc`, a choice correspondence.
        - - `n`, the number of alternatives. If no value is provided, look at all the alternatives in the choice function, which is much slower.
        - """
        - function strictUCR(cc::ChoiceCorrespondence{T}, n::Int = 0) where T <: Int
       20     if n == 0
        3         n = setofalternatives(cc)
        4     elseif n < 0
        1         throw(DomainError(n, "should be positive."))
        -     end    
        6     result = DiGraph(n)
        -     forbidden = Set{Tuple{Int, Int}}()
        6     for (key, value) = cc
      130         for k = key, v = value
       98             if k == v
       40                 continue
       58             elseif has_edge(result, k, v)
        -                 rem_edge!(result, k, v) 
       10                 push!(forbidden, (k, v))
       20                 push!(forbidden, (v, k))
       96             elseif !in((v, k), forbidden)                
      228                 add_edge!(result, v, k)
        -             end
        -         end
        -     end
        6     return result
        - end
        - 
        - """
        -     strictUCR(dg::DiGraph)
        - 
        - Create the Strict UCR graph from an observed digraph `dg`.
        - 
        - To be correct, directed graph must be obtained from strict revealed preferences.
        - 
        - # Arguments
        - 
        - - `dg`, a digraph from which we will build the strict unambiguous choice relation. This digraph should be the revealed preferences relation.
        - """
        - function strictUCR(dg::DiGraph)
        2     res = DiGraph(nv(dg))
        2     for e = edges(dg)
       18         if !has_edge(dg, reverse(e))
       24             add_edge!(res, e)
        -         end
        -     end
        2     return res
        - end
        - 
        - """
        -     fixedpoint(cc::ChoiceCorrespondence{T}, S::Vector{T}) where T <: Int
        - 
        - Find the fixed points of a choice correspondence `cc` in a set `S`, according to the definition of Aleskerov et al (2007).
        - 
        - # Arguments
        - 
        - - `cc`, the choice correspondence;
        - - `S`, the set considered.
        - """
        - function fixedpoint(cc::ChoiceCorrespondence{T}, S::Vector{T}) where T <: Int
       22     if !haskey(cc, S)
        1         throw(KeyError(S))
        -     end
        -     result = Vector{T}()
       10     for x = S
        -         bestx = true
       34         if in(x, cc[S]) 
       10             for (U, cU) = cc
      460                 if issubset(U, S) & !(U == S) & in(x, U) & !in(x, cU)
        -                     bestx = false
       92                     break
        -                 end
        -             end
       10             if bestx 
       34                 push!(result, x)
        -             end
        -         end
        -     end
       10     return result
        - end
        - 
        - """
        -     fixedpointpreferences(cc::ChoiceCorrespondence{T}, n::Int = 0) where T <: Int
        - 
        - Return the preferences revealed with the Fixed Point axio of Aleskerov et al (2007), from a choice correspondence `cc`.
        - 
        - # Arguments
        - 
        - - `cc`, the choice correspondence;
        - - `n`, the number of alternatives considered.
        - """
        - function fixedpointpreferences(cc::ChoiceCorrespondence{T}, n::Int = 0) where T <: Int
       18     if n == 0
        3         n = setofalternatives(cc)
        3     elseif n < 0
        1         throw(DomainError(n, "should be positive."))
        -     end    
        5     dg = DiGraph(n)
        -     g = Graph(n)
        -     S = collect(1:n)
        -     FP = Vector{T}()
       22     while (length(S) >=2)
        8         bestS = fixedpoint(cc, S)
        8         if issubset(bestS, FP)
        2             return dg, g
        -         else
        -             FP = union(FP, bestS)
        -         end
        6         for x = bestS
        -             setdiff!(S, FP)
        6             for t = S
       12                 add_edge!(dg, x, t)
        -             end
        6             for t = bestS
        6                 if !(t == x) 
       12                     add_edge!(g, x, t)
        -                 end
        -             end
        -         end
        -     end
        3     return dg, g
        - end
        - 
